{"entries":[{"timestamp":1716548119641,"editorVersion":"2.0.2","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"l\"><"],[-1,"variables></variables><"],[0,"bloc"]],"start1":52,"start2":52,"length1":31,"length2":8},{"diffs":[[0," y=\"0\"><"],[1,"statement name=\"HANDLER\"><block type=\"mixer_play_sound\"><field name=\"sound\">music.baDing</field></block></statement><"],[0,"/block><"]],"start1":87,"start2":87,"length1":16,"length2":133}]},{"type":"removed","filename":"main.py","value":"music.ba_ding.play()"},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[1,"music.baDing.play()"],[0,"\n"]],"start1":0,"start2":0,"length1":1,"length2":20}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"\": \""],[-1,"Untitled"],[1,"with music"],[0,"\",\n "]],"start1":11,"start2":11,"length1":16,"length2":18},{"diffs":[[0,"son\""],[-1,"\n    ]"],[1,",\n        \"main.py\",\n        \"tilemap.g.jres\",\n        \"tilemap.g.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"1.12.2\",\n        \"pxt\": \"8.5.2\"\n    },\n    \"preferredEditor\": \"pyprj\""],[0,"\n}\n"]],"start1":197,"start2":197,"length1":13,"length2":196}]},{"type":"removed","filename":"tilemap.g.jres","value":"{\n    \"transparency16\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"tilemapTile\": true\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myTiles\"\n    }\n}"},{"type":"removed","filename":"tilemap.g.ts","value":"// Auto-generated code. Do not edit.\nnamespace myTiles {\n    //% fixedInstance jres blockIdentity=images._tile\n    export const transparency16 = image.ofBuffer(hex``);\n\n    helpers._registerFactory(\"tile\", function(name: string) {\n        switch(helpers.stringTrim(name)) {\n            case \"transparency16\":return transparency16;\n        }\n        return null;\n    })\n\n}\n// Auto-generated code. Do not edit.\n"}]},{"timestamp":1716548137682,"editorVersion":"2.0.2","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"son\""],[-1,",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"pyprj\""],[1,"\n    ]"],[0,"\n}\n"]],"start1":195,"start2":195,"length1":64,"length2":13}]},{"type":"added","filename":"main.py","value":"\n"}]},{"timestamp":1718042395638,"editorVersion":"2.0.3","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"son\""],[-1,"\n    ]"],[1,",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"pyprj\""],[0,"\n}\n"]],"start1":195,"start2":195,"length1":13,"length2":64}]},{"type":"removed","filename":"main.py","value":"\n"}]},{"timestamp":1718042451690,"editorVersion":"2.0.3","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"son\""],[-1,",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"pyprj\""],[1,"\n    ]"],[0,"\n}\n"]],"start1":195,"start2":195,"length1":64,"length2":13}]},{"type":"added","filename":"main.py","value":"\n"}]},{"timestamp":1738582196381,"editorVersion":"2.0.3","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"ts"],[1,"py"],[0,"prj\"\n}\n"]],"start1":242,"start2":242,"length1":17,"length2":17}]}]},{"timestamp":1738582873677,"editorVersion":"2.0.3","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"class Map {\n    gridRows: number;\n    gridCols: number;\n    states: boolean[][] = [];\n\n    constructor(rows: number, cols: number) {\n        this.gridRows = rows;\n        this.gridCols = cols;\n        for (let r = 0; r < this.gridRows; r++) {\n            const row: boolean[] = [];\n            for (let c = 0; c < this.gridCols; c++) {\n                row.push(false);\n            }\n            this.states.push(row);\n        }\n    }\n    printMap(): void {\n        console.log(\"rows: \" )\n    }\n}"],[0,"\n"]],"start1":0,"start2":0,"length1":496,"length2":1}]}]},{"timestamp":1738583475650,"editorVersion":"2.0.3","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"  }\n"],[-1,"\n"],[0,"    p"],[-1,"ublic toString(): string {\n        let result = '';\n        result += \"rows: \" + this.gridRows\n        result += \"\\ncolumns: \" + this.gridCols\n        result += \"\\nstates:\";\n        for (let r = 0; r < this.gridRows; r++) {\n            let rowString = \"\\n\";\n            for (let c = 0; c < this.gridCols; c++) {\n                rowString += \"[\" + +this.states[r][c] + \"]\";\n            }\n            result += rowString;\n        }\n        return result;\n    }\n\n    private countNeighbours(row: number, col: number) {\n        let count = 0;\n        for (let i = -1; i < 2; i++) {\n            for (let j = -1; j < 2; j++) {\n                if (i == 0 && j == 0) {\n                    continue;\n                }\n                let neighbourX = col + i;\n                let neighbourY = row + j;\n                \n            }\n        }\n    }\n}\n\nconst newMap: Map = new Map(6, 4);\nconsole.log(newMap.toString());"],[1,"rintMap(): void {\n        console.log(\"rows: \" )\n    }\n}"],[0,"\n"]],"start1":430,"start2":430,"length1":920,"length2":66}]}]},{"timestamp":1738584081134,"editorVersion":"2.0.3","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," }\n\n"],[-1,"    \n\n"],[0,"    "]],"start1":431,"start2":431,"length1":14,"length2":8},{"diffs":[[0,"ing += \""],[1,"["],[0,"\" + +thi"]],"start1":774,"start2":774,"length1":16,"length2":17},{"diffs":[[0,"][c] + \""],[1,"]"],[0,"\";\n     "]],"start1":801,"start2":801,"length1":16,"length2":17},{"diffs":[[0," number)"],[-1,": number"],[0," {\n     "]],"start1":945,"start2":945,"length1":24,"length2":16},{"diffs":[[0,"    "],[-1,"console.log(\"[\" + neighbourX + \", \" + neighbourY + \"]\")\n                if (\n                    neighbourX < 0 ||\n                    neighbourY < 0 ||\n                    neighbourX >= this.gridCols ||\n                    neighbourY >= this.gridRows\n                ) {\n                    count++;\n                }\n            }\n        }\n        return count;"],[1,"\n            }\n        }"],[0,"\n   "]],"start1":1245,"start2":1245,"length1":372,"length2":32},{"diffs":[[0,"new Map("],[-1,"160, 120"],[1,"6, 4"],[0,");\nconso"]],"start1":1303,"start2":1303,"length1":24,"length2":20},{"diffs":[[0,"));\n"],[-1,"\n// let bg = sprites.create(image.create(160, 120));\n// console.log(bg.image);\n"]],"start1":1346,"start2":1346,"length1":83,"length2":4}]}]},{"timestamp":1738584681157,"editorVersion":"2.0.3","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"    "],[-1,"public randomise(livingPercent: number = 0.5): void {\n        for (let r = 0; r < this.gridRows; r++) {\n            for (let c = 0; c < this.gridCols; c++) {\n                this.states[r][c] = Math.random() < livingPercent;\n            }\n        }\n    }"],[0,"\n\n  "]],"start1":435,"start2":435,"length1":262,"length2":8},{"diffs":[[0,"}\n\nc"],[-1,"lass Renderer {\n    drawToImage(states: boolean[][], image: Image): void {\n        for (let r=  0; r < states.length; r++) {\n            for (let c = 0; c < states[0].length; c++) {\n                image.setPixel(c, r, states[r][c] ? 0 : 1);\n            }\n        }\n    }\n}\n\nconst newMap: Map = new Map(5, 5);\nconsole.log(newMap.toString());\nnewMap.randomise("],[1,"onst newMap: Map = new Map(160, 120"],[0,");\nc"]],"start1":1632,"start2":1632,"length1":367,"length2":43},{"diffs":[[0,"ng());\n\n"],[1,"// "],[0,"let bg ="]],"start1":1699,"start2":1699,"length1":16,"length2":19},{"diffs":[[0,"));\n"],[1,"// console.log("],[0,"bg.image"],[-1,".fill(1"],[0,");\n"]],"start1":1755,"start2":1755,"length1":22,"length2":30}]}]},{"timestamp":1738585291804,"editorVersion":"2.0.3","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"tructor("],[-1,"col"],[1,"row"],[0,"s: numbe"]],"start1":95,"start2":95,"length1":19,"length2":19},{"diffs":[[0,"number, "],[-1,"row"],[1,"col"],[0,"s: numbe"]],"start1":109,"start2":109,"length1":19,"length2":19},{"diffs":[[0,"  }\n"],[-1,"}\n\nclass MapProcGen {"],[0,"\n   "]],"start1":1153,"start2":1153,"length1":29,"length2":8},{"diffs":[[0,"ount"],[-1,"Cell"],[0,"Neig"]],"start1":1171,"start2":1171,"length1":12,"length2":8},{"diffs":[[0,"ghbours("],[-1,"states: boolean[][], "],[0,"row: num"]],"start1":1178,"start2":1178,"length1":37,"length2":16},{"diffs":[[0,"ourX >= "],[-1,"states.length"],[1,"this.gridCols"],[0," ||\n    "]],"start1":1694,"start2":1694,"length1":29,"length2":29},{"diffs":[[0,"ourY >= "],[-1,"states[0].length"],[1,"this.gridRows"],[0,"\n       "]],"start1":1745,"start2":1745,"length1":32,"length2":29},{"diffs":[[0,"    "],[-1,"//"],[0,"count++;"],[-1," -- could count OOB neighbours. either/or works\n                    continue;\n                }\n                if (states[neighbourX][neighbourY]) count++;"],[1,"\n                }"],[0,"\n   "]],"start1":1803,"start2":1803,"length1":174,"length2":34},{"diffs":[[0,"\n\nclass "],[-1,"Map"],[0,"Renderer"]],"start1":1887,"start2":1887,"length1":19,"length2":16},{"diffs":[[0,"    "],[-1,"public static "],[0,"draw"]],"start1":1906,"start2":1906,"length1":22,"length2":8},{"diffs":[[0,"    "],[-1,"const gridRows = states.length;\n        const gridCols ="],[1,"for (let r=  0; r <"],[0," states"],[-1,"[0]"],[0,".length;"],[-1,"\n        const scaleX = image.width / gridCols;\n        const scaleY = image.height / gridRows;\n\n        for (let r = 0; r < gridRows; r++) {\n            for (let c = 0; c < gridCols; c++) {\n                const col"],[1," r++) {\n            for (let c = 0; c < states[0].length; c++) {"],[0,"\n   "]],"start1":1969,"start2":1969,"length1":298,"length2":106},{"diffs":[[0,"new Map("],[-1,"160, 120"],[1,"5, 5"],[0,");\nconso"]],"start1":2185,"start2":2185,"length1":24,"length2":20},{"diffs":[[0,"1);\n"],[-1,"\nMapRenderer.drawToImage(newMap.states, bg.image);"]],"start1":2348,"start2":2348,"length1":54,"length2":4}]}]},{"timestamp":1738585892629,"editorVersion":"2.0.3","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"/**\n * Represents a 2D map of cells with binary living or dead states. i.e. a wall or a floor.\n */\n"],[0,"clas"]],"start1":0,"start2":0,"length1":103,"length2":4},{"diffs":[[0,"\n}\n\n"],[-1,"/**\n * Static class containing ProcGen logic to be applied to a Map.\n */\n"],[0,"clas"]],"start1":1156,"start2":1156,"length1":81,"length2":8},{"diffs":[[0,"private "],[-1,"static "],[0,"countCel"]],"start1":1183,"start2":1183,"length1":23,"length2":16},{"diffs":[[0,"\n}\n\n"],[-1,"/**\n * Static \n */\n"],[0,"clas"]],"start1":2074,"start2":2074,"length1":27,"length2":8},{"diffs":[[0,"r {\n"],[-1,"    /**\n     * Takes a set of cell states and draws them to an image.\n     * \n     * @param {boolean[][]} states - 2D array of cell states.\n     * @param {Image} image - The image to draw to.\n     * @param {boolean} [scale = true] - If the states should scale to fit the image.\n     */\n"],[0,"    "]],"start1":2094,"start2":2094,"length1":294,"length2":8},{"diffs":[[0,"mage"],[-1,", scale: boolean = true"],[0,"): v"]],"start1":2157,"start2":2157,"length1":31,"length2":8},{"diffs":[[0," col"],[-1," = states[r][c] ? 0 : 1;\n                \n                if (scale) {\n                    for (let dy = 0; dy < scaleY; dy++) {\n                        for (let dx = 0; dx < scaleX; dx++) {\n                            const imageX = c * scaleX + dx;\n                            const imageY = r * scaleY + dy;\n                            image.setPixel(imageX, imageY, col);\n                        }\n                    }\n                } else {\n                    image.setPixel(r, c, col);\n                }"],[1,"\n                image.setPixel(c, r, states[r][c] ? 0 : 1);"],[0,"\n   "]],"start1":2465,"start2":2465,"length1":521,"length2":68},{"diffs":[[0,"mage"],[-1,", true"],[0,");"]],"start1":2798,"start2":2798,"length1":12,"length2":6}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"\": \""],[-1,"Conway's Game of Life"],[1,"Untitled"],[0,"\",\n "]],"start1":11,"start2":11,"length1":29,"length2":16}]}]},{"timestamp":1738586195738,"editorVersion":"2.0.3","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"e(living"],[-1,"Chance"],[1,"Percent"],[0,": number"]],"start1":553,"start2":553,"length1":22,"length2":23},{"diffs":[[0,"ving"],[-1,"Chance"],[1,"Percent"],[0,";\n  "]],"start1":750,"start2":750,"length1":14,"length2":15},{"diffs":[[0,"tic "],[-1,"class containing logic for rendering a Map."],[0,"\n */"]],"start1":2267,"start2":2267,"length1":51,"length2":8},{"diffs":[[0,");\n\n"],[-1,"setInterval(() => {\n    const map: Map = new Map(160 * Math.random(), 120 * Math.random());\n    map.randomise()\n    "],[0,"MapR"]],"start1":3711,"start2":3711,"length1":124,"length2":8},{"diffs":[[0,"ToImage("],[-1,"m"],[1,"newM"],[0,"ap.state"]],"start1":3731,"start2":3731,"length1":17,"length2":20},{"diffs":[[0,"ue);"],[-1,"\n}, 3000)"]],"start1":3766,"start2":3766,"length1":13,"length2":4}]}]},{"timestamp":1738587029739,"editorVersion":"2.0.3","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"t;\n    }"],[-1,"\n\n    "],[0,"\n}\n\n/**\n"]],"start1":2243,"start2":2243,"length1":22,"length2":16}]}]},{"timestamp":1738587634844,"editorVersion":"2.0.3","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ow + j;\n"],[1,"                console.log(\"[\" + neighbourX + \", \" + neighbourY + \"]\")\n"],[0,"        "]],"start1":1714,"start2":1714,"length1":16,"length2":88},{"diffs":[[0,"           if (\n"],[-1,""],[0,"                "]],"start1":1799,"start2":1799,"length1":32,"length2":32},{"diffs":[[0," }\n\n"],[1,""],[0,"    "],[-1,"public static cellularAutomataStep(states: boolean[][]): boolean[][] {\n        const gridRows = states.length;\n        const gridCols = states[0].length;\n        let newStates: boolean[][] = [];\n\n        for (let r = 0; r < gridRows; r++) {\n            newStates[r] = [];\n            for (let c = 0; c < gridCols; c++) {\n                const livingNeighbours = MapProcGen.countCellNeighbours(states, r, c);\n                if (\n                    (states[r][c] && livingNeighbours >= 4) ||\n                    (!states[r][c] && livingNeighbours >= 5 || livingNeighbours === 0)\n                ) {\n                    newStates[r][c] = true;\n                } else {\n                    newStates[r][c] = false;\n                }\n            }\n        }\n\n        return newStates;\n    }"],[0,"\n}\n\n"]],"start1":2249,"start2":2249,"length1":799,"length2":12},{"diffs":[[0,"Map("],[-1,"80, 60);\n    map.randomise()\n    const drawStep = () => {\n  "],[1,"160 * Math.random(), 120 * Math.random());\n"],[0,"    "],[-1,"  "],[0,"map."],[-1,"states = MapProcGen.cellularAutomataStep(map.states);\n        MapRenderer.drawToImage(map.states, bg.image, true);\n        pause(500)\n    }\n    for (let i = 0; i < 6; i++) {\n        drawStep();\n    }"],[1,"randomise()\n    MapRenderer.drawToImage(map.states, bg.image, true);"],[0,"\n}, "],[-1,"5"],[1,"3"],[0,"000)"]],"start1":3807,"start2":3807,"length1":282,"length2":132}]}]},{"timestamp":1738588256605,"editorVersion":"2.0.3","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"bour"],[-1,"Row = row"],[1,"X = col"],[0," + i"]],"start1":1663,"start2":1663,"length1":17,"length2":15},{"diffs":[[0,"bour"],[-1,"Col = col"],[1,"Y = row"],[0," + j"]],"start1":1705,"start2":1705,"length1":17,"length2":15},{"diffs":[[0,"eighbour"],[-1,"Row"],[1,"X"],[0," < 0 ||\n"]],"start1":1764,"start2":1764,"length1":19,"length2":17},{"diffs":[[0,"eighbour"],[-1,"Col"],[1,"Y"],[0," < 0 ||\n"]],"start1":1802,"start2":1802,"length1":19,"length2":17},{"diffs":[[0,"eighbour"],[-1,"Row"],[1,"X"],[0," >= stat"]],"start1":1840,"start2":1840,"length1":19,"length2":17},{"diffs":[[0,"eighbour"],[-1,"Col"],[1,"Y"],[0," >= stat"]],"start1":1891,"start2":1891,"length1":19,"length2":17},{"diffs":[[0,"eighbour"],[-1,"Row"],[1,"X"],[0,"][neighb"]],"start1":2095,"start2":2095,"length1":19,"length2":17},{"diffs":[[0,"eighbour"],[-1,"Col"],[1,"Y"],[0,"]) count"]],"start1":2107,"start2":2107,"length1":19,"length2":17},{"diffs":[[0,"  }\n"],[-1,"        console.log(newStates.length);\n        console.log(newStates[0].length);"],[0,"\n   "]],"start1":2936,"start2":2936,"length1":88,"length2":8},{"diffs":[[0,"States;\n"],[-1,"\n"],[0,"    }\n}\n"]],"start1":2959,"start2":2959,"length1":17,"length2":16},{"diffs":[[0,"   }\n}\n\n"],[1,"const newMap: Map = new Map(160, 120);\nconsole.log(newMap.toString());\nnewMap.randomise();\nconsole.log(newMap.toString());\n\n"],[0,"let bg ="]],"start1":4277,"start2":4277,"length1":16,"length2":140},{"diffs":[[0,"));\n"],[-1,"\nconst renderCellularAutomataSteps = "],[1,"bg.image.fill(1);\n\nsetInterval("],[0,"() ="]],"start1":4454,"start2":4454,"length1":45,"length2":39},{"diffs":[[0,"e()\n"],[-1,"    MapRenderer.drawToImage(map.states, bg.image);\n"],[0,"    "]],"start1":4551,"start2":4551,"length1":59,"length2":8},{"diffs":[[0,"> {\n"],[-1,"        pause(500)\n"],[0,"    "]],"start1":4580,"start2":4580,"length1":27,"length2":8},{"diffs":[[0,"bg.image"],[1,", true"],[0,");\n"],[1,"        pause(500)\n"],[0,"    }\n  "]],"start1":4694,"start2":4694,"length1":19,"length2":44},{"diffs":[[0,"i < "],[-1,"10"],[1,"6"],[0,"; i+"]],"start1":4756,"start2":4756,"length1":10,"length2":9},{"diffs":[[0,"  }\n"],[-1,"}\n\nrenderCellularAutomataSteps();\nsetInterval(() => {\n    renderCellularAutomataSteps();\n"],[0,"}, 5"]],"start1":4792,"start2":4792,"length1":97,"length2":8}]}]},{"timestamp":1738588754177,"editorVersion":"2.0.3","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"new Map("],[-1,"160, 12"],[1,"80, 6"],[0,"0);\n    "]],"start1":4497,"start2":4497,"length1":23,"length2":21}]}]},{"timestamp":1738592148063,"editorVersion":"2.0.3","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ate("],[-1,"84"],[1,"160"],[0,", 12"]],"start1":4415,"start2":4415,"length1":10,"length2":11}]}]},{"timestamp":1738592353017,"editorVersion":"2.0.3","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,".create("],[-1,"160"],[1,"84"],[0,", 120));"]],"start1":4411,"start2":4411,"length1":19,"length2":18}]}]},{"timestamp":1738597618552,"editorVersion":"2.0.3","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"\n\n    }\n"],[-1,"    \n"],[0,"}\n\n/**\n "]],"start1":3062,"start2":3062,"length1":21,"length2":16}]}]},{"timestamp":1738598262207,"editorVersion":"2.0.3","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"n {\n"],[-1,"    /**\n     * Counts the living cell neighbours of a given cell in a 2D array of cell states.\n     * \n     * @param {boolean[][]} states - 2D array of cell states.\n     * @param {number} row - The row of the cell to be checked.\n     * @param {number} col - The column of the cell to be checked.\n     * @returns {number} - The number of living (true) neighbours of the cell.\n     */\n"],[0,"    "]],"start1":1345,"start2":1345,"length1":391,"length2":8},{"diffs":[[0," }\n\n"],[-1,"    /**\n     * Takes a single CA step on a map state and returns the evolved state.\n     * \n     * @param {boolean[][]} states - 2D array of cell states.\n     * @returns {boolean[][]} - 2D array of evolved cell states.\n     */\n"],[0,"    "]],"start1":2193,"start2":2193,"length1":235,"length2":8},{"diffs":[[0,"tes;\n\n    }\n"],[1,"    \n"],[0,"}\n\n/**\n * St"]],"start1":3058,"start2":3058,"length1":24,"length2":29},{"diffs":[[0," = ("],[-1,"count: number"],[0,") =>"]],"start1":4470,"start2":4470,"length1":21,"length2":8},{"diffs":[[0," 0; i < "],[-1,"count"],[1,"10"],[0,"; i++) {"]],"start1":4783,"start2":4783,"length1":21,"length2":18},{"diffs":[[0,"taSteps("],[-1,"10"],[0,");\nsetIn"]],"start1":4851,"start2":4851,"length1":18,"length2":16},{"diffs":[[0,"taSteps("],[-1,"10"],[0,");\n}, 50"]],"start1":4906,"start2":4906,"length1":18,"length2":16}]}]},{"timestamp":1738598588646,"editorVersion":"2.0.3","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," }\n\n"],[-1,"    // TODO: This should probably be in MapProcGen.\n"],[0,"    "]],"start1":530,"start2":530,"length1":60,"length2":8},{"diffs":[[0," }\n\n"],[-1,"    // TODO: Anything more complicated than toString should arguably go to the MapRenderer.\n"],[0,"    "]],"start1":788,"start2":788,"length1":100,"length2":8},{"diffs":[[0,") {\n"],[-1,"                // Don't count own cell.\n"],[0,"    "]],"start1":1929,"start2":1929,"length1":49,"length2":8},{"diffs":[[0," j;\n"],[-1,"                // Don't count out-of-bounds cells.\n"],[0,"    "]],"start1":2105,"start2":2105,"length1":60,"length2":8},{"diffs":[[0,"    "],[1,"//"],[0,"co"],[1,"u"],[0,"nt"],[-1,"inue;\n                }\n                // If cell is alive, increment neighbour count."],[1,"++; -- could count OOB neighbours. either/or works\n                    continue;\n                }"],[0,"\n   "]],"start1":2352,"start2":2352,"length1":99,"length2":113},{"diffs":[[0,"    }\n        }\n"],[1,"        console.log(newStates.length);\n        console.log(newStates[0].length);\n"],[0,"        return n"]],"start1":3550,"start2":3550,"length1":32,"length2":113},{"diffs":[[0,"States;\n"],[1,"\n"],[0,"    }\n}\n"]],"start1":3665,"start2":3665,"length1":16,"length2":17}]}]},{"timestamp":1738666579150,"editorVersion":"2.0.3","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"MapRende"],[1,"rer"],[0," {\n    /"]],"start1":3892,"start2":3892,"length1":16,"length2":19}]}]},{"timestamp":1738667189275,"editorVersion":"2.0.3","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"s Map {\n    "],[-1,"readonly "],[0,"gridRows: nu"]],"start1":103,"start2":103,"length1":33,"length2":24},{"diffs":[[0,"    "],[-1,"readonly "],[0,"grid"]],"start1":133,"start2":133,"length1":17,"length2":8},{"diffs":[[0,"MapRende"],[-1,"rer"],[0," {\n    /"]],"start1":3892,"start2":3892,"length1":19,"length2":16}]}]},{"timestamp":1738667791220,"editorVersion":"2.0.3","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," }\n\n"],[-1,"    public update(transform: (currentStates: boolean[][]) => boolean[][]): void {\n        let newStates = transform(this.states);\n        if (\n            newStates.length == this.gridRows &&\n            newStates[0].length === this.gridCols\n        ) {\n            this.states = newStates;\n        } else {\n            // throw \n        }\n    }\n\n"],[0,"    "]],"start1":548,"start2":548,"length1":355,"length2":8},{"diffs":[[0,"00)\n"],[-1,"        map.update(MapProcGen.cellularAutomataStep());\n"],[0,"    "]],"start1":5413,"start2":5413,"length1":63,"length2":8}]}]},{"timestamp":1738668495302,"editorVersion":"2.0.3","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"number;\n    "],[-1,"private "],[0,"states: bool"]],"start1":165,"start2":165,"length1":32,"length2":24},{"diffs":[[0," }\n\n"],[-1,"    public getStates(): boolean[][] { return this.states; }\n\n"],[0,"    "]],"start1":548,"start2":548,"length1":69,"length2":8},{"diffs":[[0,"ToImage(map."],[-1,"getS"],[1,"s"],[0,"tates"],[-1,"()"],[0,", bg.image);"]],"start1":5685,"start2":5685,"length1":35,"length2":30},{"diffs":[[0,"ate("],[1,"MapProcGen.cellularAutomataStep());\n        map."],[0,"states ="],[-1,">"],[0," Map"]],"start1":5779,"start2":5779,"length1":17,"length2":64},{"diffs":[[0,"tep("],[1,"map."],[0,"states)"],[-1,")"],[0,";\n  "]],"start1":5868,"start2":5868,"length1":16,"length2":19},{"diffs":[[0,"map."],[-1,"getS"],[1,"s"],[0,"tates"],[-1,"()"],[0,", bg"]],"start1":5917,"start2":5917,"length1":19,"length2":14}]}]},{"timestamp":1738669113193,"editorVersion":"2.0.3","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"s Map {\n    "],[-1,"private "],[0,"readonly gri"]],"start1":103,"start2":103,"length1":32,"length2":24},{"diffs":[[0,"er;\n    "],[-1,"private "],[0,"readonly"]],"start1":138,"start2":138,"length1":24,"length2":16},{"diffs":[[0,") {\n"],[-1,"            throw \"Transformed Map states don't fit the map grid.\" }\n"],[0,"    "]],"start1":871,"start2":871,"length1":77,"length2":8},{"diffs":[[0,"    "],[1," //"],[0," throw "],[-1," { message: \"Transformed Map states don't fit the map grid.\" } "],[0,"\n   "]],"start1":936,"start2":936,"length1":78,"length2":18}]}]},{"timestamp":1738669720551,"editorVersion":"2.0.3","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ols\n        ) {\n"],[1,"            throw \"Transformed Map states don't fit the map grid.\" }\n"],[0,"            this"]],"start1":875,"start2":875,"length1":32,"length2":101},{"diffs":[[0,"           throw"],[1,"  { message:"],[0," \"Transformed Ma"]],"start1":1015,"start2":1015,"length1":32,"length2":44},{"diffs":[[0,"p grid.\""],[-1,";"],[1," } "],[0,"\n       "]],"start1":1084,"start2":1084,"length1":17,"length2":19},{"diffs":[[0,"    "],[-1,"public toString(): string {\n        let result = `[${this.gridRows}, ${this.gridCols}]"],[1,"// TODO: Anything more complicated than toString should arguably go to the MapRenderer.\n    public toString(): string {\n        let result = '';\n        result += \"rows: \" + this.gridRows\n        result += \"\\ncolumns: \" + this.gridCols\n        result += \""],[0,"\\nst"]],"start1":1423,"start2":1423,"length1":94,"length2":263},{"diffs":[[0,"nstates:"],[-1,"`"],[1,"\";"],[0,"\n       "]],"start1":1683,"start2":1683,"length1":17,"length2":18},{"diffs":[[0,"g = "],[-1,"this.states[r].map(cell => `${+cell}`).join('');"],[1,"\"\\n\";\n            for (let c = 0; c < this.gridCols; c++) {\n                rowString += \"\" + +this.states[r][c] + \"\";\n            }"],[0,"\n   "]],"start1":1768,"start2":1768,"length1":56,"length2":140},{"diffs":[[0," += "],[-1,"`\\n${"],[0,"rowS"]],"start1":1923,"start2":1923,"length1":13,"length2":8},{"diffs":[[0,"ring"],[-1,"}`"],[0,";\n  "]],"start1":1932,"start2":1932,"length1":10,"length2":8},{"diffs":[[0,"        "],[-1,"cons"],[1,"le"],[0,"t newSta"]],"start1":3767,"start2":3767,"length1":20,"length2":18}]}]},{"timestamp":1738670776785,"editorVersion":"2.0.3","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"    }\n}\n"],[-1,"Image"],[0,"\nlet bg "]],"start1":5375,"start2":5375,"length1":21,"length2":16}]}]},{"timestamp":1738671097319,"editorVersion":"2.0.3","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"iables><"],[1,"block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block><"],[0,"/xml>"]],"start1":71,"start2":71,"length1":13,"length2":60}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"    }\n}\n"],[1,"Image"],[0,"\nlet bg "]],"start1":5375,"start2":5375,"length1":16,"length2":21}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," ],\n"],[-1,"    \"testFiles\": [\n        \"test.ts\"\n    ],\n"],[0,"    "]],"start1":235,"start2":235,"length1":52,"length2":8}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1716548119640,"editorVersion":"2.0.2","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"mixer_play_sound\"><field name=\"sound\">music.baDing</field></block></statement></block></xml>","main.ts":"","README.md":" ","assets.json":"","main.py":"music.ba_ding.play()","tilemap.g.jres":"{\n    \"transparency16\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"tilemapTile\": true\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myTiles\"\n    }\n}","tilemap.g.ts":"","pxt.json":"{\n    \"name\": \"with music\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"main.py\",\n        \"tilemap.g.jres\",\n        \"tilemap.g.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"1.12.2\",\n        \"pxt\": \"8.5.2\"\n    },\n    \"preferredEditor\": \"pyprj\"\n}\n"}},{"timestamp":1718042395638,"editorVersion":"2.0.3","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"","README.md":" ","assets.json":"","main.py":"\n","pxt.json":"{\n    \"name\": \"Untitled\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"pyprj\"\n}\n"}},{"timestamp":1738583997986,"editorVersion":"2.0.3","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"class Map {\n    gridRows: number;\n    gridCols: number;\n    states: boolean[][] = [];\n\n    constructor(rows: number, cols: number) {\n        this.gridRows = rows;\n        this.gridCols = cols;\n        for (let r = 0; r < this.gridRows; r++) {\n            const row: boolean[] = [];\n            for (let c = 0; c < this.gridCols; c++) {\n                row.push(false);\n            }\n            this.states.push(row);\n        }\n    }\n\n    public toString(): string {\n        let result = '';\n        result += \"rows: \" + this.gridRows\n        result += \"\\ncolumns: \" + this.gridCols\n        result += \"\\nstates:\";\n        for (let r = 0; r < this.gridRows; r++) {\n            let rowString = \"\\n\";\n            for (let c = 0; c < this.gridCols; c++) {\n                rowString += \"[\" + +this.states[r][c] + \"]\";\n            }\n            result += rowString;\n        }\n        return result;\n    }\n\n    private countNeighbours(row: number, col: number): number {\n        let count = 0;\n        for (let i = -1; i < 2; i++) {\n            for (let j = -1; j < 2; j++) {\n                if (i == 0 && j == 0) {\n                    continue;\n                }\n                let neighbourX = col + i;\n                let neighbourY = row + j;\n                console.log(\"[\" + neighbourX + \", \" + neighbourY + \"]\")\n                if (\n                    neighbourX < 0 ||\n                    neighbourY < 0 ||\n                    neighbourX >= this.gridCols ||\n                    neighbourY >= this.gridRows\n                ) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}\n\nconst newMap: Map = new Map(160, 120);\nconsole.log(newMap.toString());\n\nlet bg = sprites.create(image.create(160, 120));\nbg.image.fill(0);\nconsole.log(bg.image);\n","README.md":" ","assets.json":"","main.py":"\n","pxt.json":"{\n    \"name\": \"Untitled\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1738585803670,"editorVersion":"2.0.3","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"class Map {\n    gridRows: number;\n    gridCols: number;\n    states: boolean[][] = [];\n\n    constructor(cols: number, rows: number) {\n        this.gridRows = rows;\n        this.gridCols = cols;\n        for (let r = 0; r < this.gridRows; r++) {\n            const row: boolean[] = [];\n            for (let c = 0; c < this.gridCols; c++) {\n                row.push(false);\n            }\n            this.states.push(row);\n        }\n    }\n\n    public randomise(livingPercent: number = 0.5): void {\n        for (let r = 0; r < this.gridRows; r++) {\n            for (let c = 0; c < this.gridCols; c++) {\n                this.states[r][c] = Math.random() < livingPercent;\n            }\n        }\n    }\n\n    public toString(): string {\n        let result = '';\n        result += \"rows: \" + this.gridRows\n        result += \"\\ncolumns: \" + this.gridCols\n        result += \"\\nstates:\";\n        for (let r = 0; r < this.gridRows; r++) {\n            let rowString = \"\\n\";\n            for (let c = 0; c < this.gridCols; c++) {\n                rowString += \"\" + +this.states[r][c] + \"\";\n            }\n            result += rowString;\n        }\n        return result;\n    }\n}\n\n/**\n * \n */\nclass MapProcGen {\n    private static countCellNeighbours(states: boolean[][], row: number, col: number): number {\n        let count = 0;\n        for (let i = -1; i < 2; i++) {\n            for (let j = -1; j < 2; j++) {\n                if (i == 0 && j == 0) {\n                    continue;\n                }\n                let neighbourX = col + i;\n                let neighbourY = row + j;\n                console.log(\"[\" + neighbourX + \", \" + neighbourY + \"]\")\n                if (\n                    neighbourX < 0 ||\n                    neighbourY < 0 ||\n                    neighbourX >= states.length ||\n                    neighbourY >= states[0].length\n                ) {\n                    //count++; -- could count OOB neighbours. either/or works\n                    continue;\n                }\n                if (states[neighbourX][neighbourY]) count++;\n            }\n        }\n        return count;\n    }\n}\n\nclass MapRenderer {\n    /**\n     * Takes a set of cell states and draws them to an image.\n     * \n     * @param {boolean[][]} states - 2D array of cell states.\n     * @param {Image} image - The image to draw to.\n     * @param {boolean} [scale = true] - If the states should scale to fit the image.\n     */\n    public static drawToImage(states: boolean[][], image: Image, scale: boolean = true): void {\n        const gridRows = states.length;\n        const gridCols = states[0].length;\n        const scaleX = image.width / gridCols;\n        const scaleY = image.height / gridRows;\n\n        for (let r = 0; r < gridRows; r++) {\n            for (let c = 0; c < gridCols; c++) {\n                const col = states[r][c] ? 0 : 1;\n                \n                if (scale) {\n                    for (let dy = 0; dy < scaleY; dy++) {\n                        for (let dx = 0; dx < scaleX; dx++) {\n                            const imageX = c * scaleX + dx;\n                            const imageY = r * scaleY + dy;\n                            image.setPixel(imageX, imageY, col);\n                        }\n                    }\n                } else {\n                    image.setPixel(r, c, col);\n                }\n            }\n        }\n    }\n}\n\nconst newMap: Map = new Map(160, 120);\nconsole.log(newMap.toString());\nnewMap.randomise();\nconsole.log(newMap.toString());\n\nlet bg = sprites.create(image.create(160, 120));\nbg.image.fill(1);\n\nMapRenderer.drawToImage(newMap.states, bg.image, true);","README.md":" ","assets.json":"","main.py":"\n","pxt.json":"{\n    \"name\": \"Conway's Game of Life\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1738587605956,"editorVersion":"2.0.3","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"/**\n * Represents a 2D map of cells with binary living or dead states. i.e. a wall or a floor.\n */\nclass Map {\n    gridRows: number;\n    gridCols: number;\n    states: boolean[][] = [];\n\n    constructor(cols: number, rows: number) {\n        this.gridRows = rows;\n        this.gridCols = cols;\n        for (let r = 0; r < this.gridRows; r++) {\n            const row: boolean[] = [];\n            for (let c = 0; c < this.gridCols; c++) {\n                row.push(false);\n            }\n            this.states.push(row);\n        }\n    }\n\n    public randomise(livingChance: number = 0.5): void {\n        for (let r = 0; r < this.gridRows; r++) {\n            for (let c = 0; c < this.gridCols; c++) {\n                this.states[r][c] = Math.random() < livingChance;\n            }\n        }\n    }\n\n    public toString(): string {\n        let result = '';\n        result += \"rows: \" + this.gridRows\n        result += \"\\ncolumns: \" + this.gridCols\n        result += \"\\nstates:\";\n        for (let r = 0; r < this.gridRows; r++) {\n            let rowString = \"\\n\";\n            for (let c = 0; c < this.gridCols; c++) {\n                rowString += \"\" + +this.states[r][c] + \"\";\n            }\n            result += rowString;\n        }\n        return result;\n    }\n}\n\n/**\n * Static class containing ProcGen logic to be applied to a Map.\n */\nclass MapProcGen {\n    private static countCellNeighbours(states: boolean[][], row: number, col: number): number {\n        let count = 0;\n        for (let i = -1; i < 2; i++) {\n            for (let j = -1; j < 2; j++) {\n                if (i == 0 && j == 0) {\n                    continue;\n                }\n                let neighbourX = col + i;\n                let neighbourY = row + j;\n                if (\n                    neighbourX < 0 ||\n                    neighbourY < 0 ||\n                    neighbourX >= states.length ||\n                    neighbourY >= states[0].length\n                ) {\n                    //count++; -- could count OOB neighbours. either/or works\n                    continue;\n                }\n                if (states[neighbourX][neighbourY]) count++;\n            }\n        }\n        return count;\n    }\n\n    public static cellularAutomataStep(states: boolean[][]): boolean[][] {\n        const gridRows = states.length;\n        const gridCols = states[0].length;\n        let newStates: boolean[][] = [];\n\n        for (let r = 0; r < gridRows; r++) {\n            newStates[r] = [];\n            for (let c = 0; c < gridCols; c++) {\n                const livingNeighbours = MapProcGen.countCellNeighbours(states, r, c);\n                if (\n                    (states[r][c] && livingNeighbours >= 4) ||\n                    (!states[r][c] && livingNeighbours >= 5 || livingNeighbours === 0)\n                ) {\n                    newStates[r][c] = true;\n                } else {\n                    newStates[r][c] = false;\n                }\n            }\n        }\n\n        return newStates;\n    }\n}\n\n/**\n * Static class containing logic for rendering a Map.\n */\nclass MapRenderer {\n    /**\n     * Takes a set of cell states and draws them to an image.\n     * \n     * @param {boolean[][]} states - 2D array of cell states.\n     * @param {Image} image - The image to draw to.\n     * @param {boolean} [scale = true] - If the states should scale to fit the image.\n     */\n    public static drawToImage(states: boolean[][], image: Image, scale: boolean = true): void {\n        const gridRows = states.length;\n        const gridCols = states[0].length;\n        const scaleX = image.width / gridCols;\n        const scaleY = image.height / gridRows;\n\n        for (let r = 0; r < gridRows; r++) {\n            for (let c = 0; c < gridCols; c++) {\n                const col = states[r][c] ? 0 : 1;\n                \n                if (scale) {\n                    for (let dy = 0; dy < scaleY; dy++) {\n                        for (let dx = 0; dx < scaleX; dx++) {\n                            const imageX = c * scaleX + dx;\n                            const imageY = r * scaleY + dy;\n                            image.setPixel(imageX, imageY, col);\n                        }\n                    }\n                } else {\n                    image.setPixel(r, c, col);\n                }\n            }\n        }\n    }\n}\n\nconst newMap: Map = new Map(160, 120);\nconsole.log(newMap.toString());\nnewMap.randomise();\nconsole.log(newMap.toString());\n\nlet bg = sprites.create(image.create(160, 120));\nbg.image.fill(1);\n\nsetInterval(() => {\n    const map: Map = new Map(80, 60);\n    map.randomise()\n    const drawStep = () => {\n        map.states = MapProcGen.cellularAutomataStep(map.states);\n        MapRenderer.drawToImage(map.states, bg.image, true);\n        pause(500)\n    }\n    drawStep();\n    drawStep();\n    drawStep();\n}, 3000)","README.md":" ","assets.json":"","main.py":"\n","pxt.json":"{\n    \"name\": \"Conway's Game of Life\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1738592092359,"editorVersion":"2.0.3","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"/**\n * Represents a 2D map of cells with binary living or dead states. i.e. a wall or a floor.\n */\nclass Map {\n    gridRows: number;\n    gridCols: number;\n    states: boolean[][] = [];\n\n    constructor(cols: number, rows: number) {\n        this.gridRows = rows;\n        this.gridCols = cols;\n        for (let r = 0; r < this.gridRows; r++) {\n            const row: boolean[] = [];\n            for (let c = 0; c < this.gridCols; c++) {\n                row.push(false);\n            }\n            this.states.push(row);\n        }\n    }\n\n    public randomise(livingChance: number = 0.5): void {\n        for (let r = 0; r < this.gridRows; r++) {\n            for (let c = 0; c < this.gridCols; c++) {\n                this.states[r][c] = Math.random() < livingChance;\n            }\n        }\n    }\n\n    public toString(): string {\n        let result = '';\n        result += \"rows: \" + this.gridRows\n        result += \"\\ncolumns: \" + this.gridCols\n        result += \"\\nstates:\";\n        for (let r = 0; r < this.gridRows; r++) {\n            let rowString = \"\\n\";\n            for (let c = 0; c < this.gridCols; c++) {\n                rowString += \"\" + +this.states[r][c] + \"\";\n            }\n            result += rowString;\n        }\n        return result;\n    }\n}\n\n/**\n * Static class containing ProcGen logic to be applied to a Map.\n */\nclass MapProcGen {\n    private static countCellNeighbours(states: boolean[][], row: number, col: number): number {\n        let count = 0;\n        for (let i = -1; i < 2; i++) {\n            for (let j = -1; j < 2; j++) {\n                if (i == 0 && j == 0) {\n                    continue;\n                }\n                let neighbourRow = row + i;\n                let neighbourCol = col + j;\n                if (\n                    neighbourRow < 0 ||\n                    neighbourCol < 0 ||\n                    neighbourRow >= states.length ||\n                    neighbourCol >= states[0].length\n                ) {\n                    //count++; -- could count OOB neighbours. either/or works\n                    continue;\n                }\n                if (states[neighbourRow][neighbourCol]) count++;\n            }\n        }\n        return count;\n    }\n\n    public static cellularAutomataStep(states: boolean[][]): boolean[][] {\n        const gridRows = states.length;\n        const gridCols = states[0].length;\n        let newStates: boolean[][] = [];\n\n        for (let r = 0; r < gridRows; r++) {\n            newStates[r] = [];\n            for (let c = 0; c < gridCols; c++) {\n                const livingNeighbours = MapProcGen.countCellNeighbours(states, r, c);\n                if (\n                    (states[r][c] && livingNeighbours >= 4) ||\n                    (!states[r][c] && livingNeighbours >= 5 || livingNeighbours === 0)\n                ) {\n                    newStates[r][c] = true;\n                } else {\n                    newStates[r][c] = false;\n                }\n            }\n        }\n        console.log(newStates.length);\n        console.log(newStates[0].length);\n        return newStates;\n\n    }\n}\n\n/**\n * Static class containing logic for rendering a Map.\n */\nclass MapRenderer {\n    /**\n     * Takes a set of cell states and draws them to an image.\n     * \n     * @param {boolean[][]} states - 2D array of cell states.\n     * @param {Image} image - The image to draw to.\n     * @param {boolean} [scale = true] - If the states should scale to fit the image.\n     */\n    public static drawToImage(states: boolean[][], image: Image, scale: boolean = true): void {\n        const gridRows = states.length;\n        const gridCols = states[0].length;\n        const scaleX = image.width / gridCols;\n        const scaleY = image.height / gridRows;\n\n        for (let r = 0; r < gridRows; r++) {\n            for (let c = 0; c < gridCols; c++) {\n                const col = states[r][c] ? 0 : 1;\n                \n                if (scale) {\n                    for (let dy = 0; dy < scaleY; dy++) {\n                        for (let dx = 0; dx < scaleX; dx++) {\n                            const imageX = c * scaleX + dx;\n                            const imageY = r * scaleY + dy;\n                            image.setPixel(imageX, imageY, col);\n                        }\n                    }\n                } else {\n                    image.setPixel(r, c, col);\n                }\n            }\n        }\n    }\n}\n\nlet bg = sprites.create(image.create(160, 120));\n\nconst renderCellularAutomataSteps = () => {\n    const map: Map = new Map(160, 120);\n    map.randomise()\n    MapRenderer.drawToImage(map.states, bg.image);\n    const drawStep = () => {\n        pause(500)\n        map.states = MapProcGen.cellularAutomataStep(map.states);\n        MapRenderer.drawToImage(map.states, bg.image);\n    }\n    for (let i = 0; i < 10; i++) {\n        drawStep();\n    }\n}\n\nrenderCellularAutomataSteps();\nsetInterval(() => {\n    renderCellularAutomataSteps();\n}, 5000)","README.md":" ","assets.json":"","main.py":"\n","pxt.json":"{\n    \"name\": \"Conway's Game of Life\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1738597618552,"editorVersion":"2.0.3","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"/**\n * Represents a 2D map of cells with binary living or dead states. i.e. a wall or a floor.\n */\nclass Map {\n    gridRows: number;\n    gridCols: number;\n    states: boolean[][] = [];\n\n    constructor(cols: number, rows: number) {\n        this.gridRows = rows;\n        this.gridCols = cols;\n        for (let r = 0; r < this.gridRows; r++) {\n            const row: boolean[] = [];\n            for (let c = 0; c < this.gridCols; c++) {\n                row.push(false);\n            }\n            this.states.push(row);\n        }\n    }\n\n    public randomise(livingChance: number = 0.5): void {\n        for (let r = 0; r < this.gridRows; r++) {\n            for (let c = 0; c < this.gridCols; c++) {\n                this.states[r][c] = Math.random() < livingChance;\n            }\n        }\n    }\n\n    public toString(): string {\n        let result = '';\n        result += \"rows: \" + this.gridRows\n        result += \"\\ncolumns: \" + this.gridCols\n        result += \"\\nstates:\";\n        for (let r = 0; r < this.gridRows; r++) {\n            let rowString = \"\\n\";\n            for (let c = 0; c < this.gridCols; c++) {\n                rowString += \"\" + +this.states[r][c] + \"\";\n            }\n            result += rowString;\n        }\n        return result;\n    }\n}\n\n/**\n * Static class containing ProcGen logic to be applied to a Map.\n */\nclass MapProcGen {\n    private static countCellNeighbours(states: boolean[][], row: number, col: number): number {\n        let count = 0;\n        for (let i = -1; i < 2; i++) {\n            for (let j = -1; j < 2; j++) {\n                if (i == 0 && j == 0) {\n                    continue;\n                }\n                let neighbourRow = row + i;\n                let neighbourCol = col + j;\n                if (\n                    neighbourRow < 0 ||\n                    neighbourCol < 0 ||\n                    neighbourRow >= states.length ||\n                    neighbourCol >= states[0].length\n                ) {\n                    //count++; -- could count OOB neighbours. either/or works\n                    continue;\n                }\n                if (states[neighbourRow][neighbourCol]) count++;\n            }\n        }\n        return count;\n    }\n\n    public static cellularAutomataStep(states: boolean[][]): boolean[][] {\n        const gridRows = states.length;\n        const gridCols = states[0].length;\n        let newStates: boolean[][] = [];\n\n        for (let r = 0; r < gridRows; r++) {\n            newStates[r] = [];\n            for (let c = 0; c < gridCols; c++) {\n                const livingNeighbours = MapProcGen.countCellNeighbours(states, r, c);\n                if (\n                    (states[r][c] && livingNeighbours >= 4) ||\n                    (!states[r][c] && livingNeighbours >= 5 || livingNeighbours === 0)\n                ) {\n                    newStates[r][c] = true;\n                } else {\n                    newStates[r][c] = false;\n                }\n            }\n        }\n        console.log(newStates.length);\n        console.log(newStates[0].length);\n        return newStates;\n\n    }\n}\n\n/**\n * Static class containing logic for rendering a Map.\n */\nclass MapRenderer {\n    /**\n     * Takes a set of cell states and draws them to an image.\n     * \n     * @param {boolean[][]} states - 2D array of cell states.\n     * @param {Image} image - The image to draw to.\n     * @param {boolean} [scale = true] - If the states should scale to fit the image.\n     */\n    public static drawToImage(states: boolean[][], image: Image, scale: boolean = true): void {\n        const gridRows = states.length;\n        const gridCols = states[0].length;\n        const scaleX = image.width / gridCols;\n        const scaleY = image.height / gridRows;\n\n        for (let r = 0; r < gridRows; r++) {\n            for (let c = 0; c < gridCols; c++) {\n                const col = states[r][c] ? 0 : 1;\n                \n                if (scale) {\n                    for (let dy = 0; dy < scaleY; dy++) {\n                        for (let dx = 0; dx < scaleX; dx++) {\n                            const imageX = c * scaleX + dx;\n                            const imageY = r * scaleY + dy;\n                            image.setPixel(imageX, imageY, col);\n                        }\n                    }\n                } else {\n                    image.setPixel(r, c, col);\n                }\n            }\n        }\n    }\n}\n\nlet bg = sprites.create(image.create(160, 120));\n\nconst renderCellularAutomataSteps = () => {\n    const map: Map = new Map(160, 120);\n    map.randomise()\n    MapRenderer.drawToImage(map.states, bg.image);\n    const drawStep = () => {\n        pause(500)\n        map.states = MapProcGen.cellularAutomataStep(map.states);\n        MapRenderer.drawToImage(map.states, bg.image);\n    }\n    for (let i = 0; i < 10; i++) {\n        drawStep();\n    }\n}\n\nrenderCellularAutomataSteps();\nsetInterval(() => {\n    renderCellularAutomataSteps();\n}, 5000)","README.md":" ","assets.json":"","main.py":"\n","pxt.json":"{\n    \"name\": \"Conway's Game of Life\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1738604281446,"editorVersion":"2.0.3","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"/**\n * Represents a 2D map of cells with binary living or dead states. i.e. a wall or a floor.\n */\nclass Map {\n    gridRows: number;\n    gridCols: number;\n    states: boolean[][] = [];\n\n    constructor(cols: number, rows: number) {\n        this.gridRows = rows;\n        this.gridCols = cols;\n        for (let r = 0; r < this.gridRows; r++) {\n            const row: boolean[] = [];\n            for (let c = 0; c < this.gridCols; c++) {\n                row.push(false);\n            }\n            this.states.push(row);\n        }\n    }\n\n    // TODO: This should probably be in MapProcGen.\n    public randomise(livingChance: number = 0.5): void {\n        for (let r = 0; r < this.gridRows; r++) {\n            for (let c = 0; c < this.gridCols; c++) {\n                this.states[r][c] = Math.random() < livingChance;\n            }\n        }\n    }\n\n    // TODO: Anything more complicated than toString should arguably go to the MapRenderer.\n    public toString(): string {\n        let result = '';\n        result += \"rows: \" + this.gridRows\n        result += \"\\ncolumns: \" + this.gridCols\n        result += \"\\nstates:\";\n        for (let r = 0; r < this.gridRows; r++) {\n            let rowString = \"\\n\";\n            for (let c = 0; c < this.gridCols; c++) {\n                rowString += \"\" + +this.states[r][c] + \"\";\n            }\n            result += rowString;\n        }\n        return result;\n    }\n}\n\n/**\n * Static class containing ProcGen logic to be applied to a Map.\n */\nclass MapProcGen {\n    /**\n     * Counts the living cell neighbours of a given cell in a 2D array of cell states.\n     * \n     * @param {boolean[][]} states - 2D array of cell states.\n     * @param {number} row - The row of the cell to be checked.\n     * @param {number} col - The column of the cell to be checked.\n     * @returns {number} - The number of living (true) neighbours of the cell.\n     */\n    private static countCellNeighbours(states: boolean[][], row: number, col: number): number {\n        let count = 0;\n        for (let i = -1; i < 2; i++) {\n            for (let j = -1; j < 2; j++) {\n                // Don't count own cell.\n                if (i == 0 && j == 0) {\n                    continue;\n                }\n                let neighbourRow = row + i;\n                let neighbourCol = col + j;\n                // Don't count out-of-bounds cells.\n                if (\n                    neighbourRow < 0 ||\n                    neighbourCol < 0 ||\n                    neighbourRow >= states.length ||\n                    neighbourCol >= states[0].length\n                ) {\n                    continue;\n                }\n                // If cell is alive, increment neighbour count.\n                if (states[neighbourRow][neighbourCol]) count++;\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Takes a single CA step on a map state and returns the evolved state.\n     * \n     * @param {boolean[][]} states - 2D array of cell states.\n     * @returns {boolean[][]} - 2D array of evolved cell states.\n     */\n    public static cellularAutomataStep(states: boolean[][]): boolean[][] {\n        const gridRows = states.length;\n        const gridCols = states[0].length;\n        let newStates: boolean[][] = [];\n\n        for (let r = 0; r < gridRows; r++) {\n            newStates[r] = [];\n            for (let c = 0; c < gridCols; c++) {\n                const livingNeighbours = MapProcGen.countCellNeighbours(states, r, c);\n                if (\n                    (states[r][c] && livingNeighbours >= 4) ||\n                    (!states[r][c] && livingNeighbours >= 5 || livingNeighbours === 0)\n                ) {\n                    newStates[r][c] = true;\n                } else {\n                    newStates[r][c] = false;\n                }\n            }\n        }\n        return newStates;\n    }\n}\n\n/**\n * Static class containing logic for rendering a Map.\n */\nclass MapRenderer {\n    /**\n     * Takes a set of cell states and draws them to an image.\n     * \n     * @param {boolean[][]} states - 2D array of cell states.\n     * @param {Image} image - The image to draw to.\n     * @param {boolean} [scale = true] - If the states should scale to fit the image.\n     */\n    public static drawToImage(states: boolean[][], image: Image, scale: boolean = true): void {\n        const gridRows = states.length;\n        const gridCols = states[0].length;\n        const scaleX = image.width / gridCols;\n        const scaleY = image.height / gridRows;\n\n        for (let r = 0; r < gridRows; r++) {\n            for (let c = 0; c < gridCols; c++) {\n                const col = states[r][c] ? 0 : 1;\n                \n                if (scale) {\n                    for (let dy = 0; dy < scaleY; dy++) {\n                        for (let dx = 0; dx < scaleX; dx++) {\n                            const imageX = c * scaleX + dx;\n                            const imageY = r * scaleY + dy;\n                            image.setPixel(imageX, imageY, col);\n                        }\n                    }\n                } else {\n                    image.setPixel(r, c, col);\n                }\n            }\n        }\n    }\n}\n\nlet bg = sprites.create(image.create(160, 120));\n\nconst renderCellularAutomataSteps = (count: number) => {\n    const map: Map = new Map(160, 120);\n    map.randomise()\n    MapRenderer.drawToImage(map.states, bg.image);\n    const drawStep = () => {\n        pause(500)\n        map.states = MapProcGen.cellularAutomataStep(map.states);\n        MapRenderer.drawToImage(map.states, bg.image);\n    }\n    for (let i = 0; i < count; i++) {\n        drawStep();\n    }\n}\n\nrenderCellularAutomataSteps(10);\nsetInterval(() => {\n    renderCellularAutomataSteps(10);\n}, 5000)","README.md":" ","assets.json":"","main.py":"\n","pxt.json":"{\n    \"name\": \"Conway's Game of Life\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1738666579150,"editorVersion":"2.0.3","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"/**\n * Represents a 2D map of cells with binary living or dead states. i.e. a wall or a floor.\n */\nclass Map {\n    gridRows: number;\n    gridCols: number;\n    states: boolean[][] = [];\n\n    constructor(cols: number, rows: number) {\n        this.gridRows = rows;\n        this.gridCols = cols;\n        for (let r = 0; r < this.gridRows; r++) {\n            const row: boolean[] = [];\n            for (let c = 0; c < this.gridCols; c++) {\n                row.push(false);\n            }\n            this.states.push(row);\n        }\n    }\n\n    // TODO: This should probably be in MapProcGen.\n    public randomise(livingChance: number = 0.5): void {\n        for (let r = 0; r < this.gridRows; r++) {\n            for (let c = 0; c < this.gridCols; c++) {\n                this.states[r][c] = Math.random() < livingChance;\n            }\n        }\n    }\n\n    // TODO: Anything more complicated than toString should arguably go to the MapRenderer.\n    public toString(): string {\n        let result = '';\n        result += \"rows: \" + this.gridRows\n        result += \"\\ncolumns: \" + this.gridCols\n        result += \"\\nstates:\";\n        for (let r = 0; r < this.gridRows; r++) {\n            let rowString = \"\\n\";\n            for (let c = 0; c < this.gridCols; c++) {\n                rowString += \"\" + +this.states[r][c] + \"\";\n            }\n            result += rowString;\n        }\n        return result;\n    }\n}\n\n/**\n * Static class containing ProcGen logic to be applied to a Map.\n */\nclass MapProcGen {\n    /**\n     * Counts the living cell neighbours of a given cell in a 2D array of cell states.\n     * \n     * @param {boolean[][]} states - 2D array of cell states.\n     * @param {number} row - The row of the cell to be checked.\n     * @param {number} col - The column of the cell to be checked.\n     * @returns {number} - The number of living (true) neighbours of the cell.\n     */\n    private static countCellNeighbours(states: boolean[][], row: number, col: number): number {\n        let count = 0;\n        for (let i = -1; i < 2; i++) {\n            for (let j = -1; j < 2; j++) {\n                // Don't count own cell.\n                if (i == 0 && j == 0) {\n                    continue;\n                }\n                let neighbourRow = row + i;\n                let neighbourCol = col + j;\n                // Don't count out-of-bounds cells.\n                if (\n                    neighbourRow < 0 ||\n                    neighbourCol < 0 ||\n                    neighbourRow >= states.length ||\n                    neighbourCol >= states[0].length\n                ) {\n                    continue;\n                }\n                // If cell is alive, increment neighbour count.\n                if (states[neighbourRow][neighbourCol]) count++;\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Takes a single CA step on a map state and returns the evolved state.\n     * \n     * @param {boolean[][]} states - 2D array of cell states.\n     * @returns {boolean[][]} - 2D array of evolved cell states.\n     */\n    public static cellularAutomataStep(states: boolean[][]): boolean[][] {\n        const gridRows = states.length;\n        const gridCols = states[0].length;\n        let newStates: boolean[][] = [];\n\n        for (let r = 0; r < gridRows; r++) {\n            newStates[r] = [];\n            for (let c = 0; c < gridCols; c++) {\n                const livingNeighbours = MapProcGen.countCellNeighbours(states, r, c);\n                if (\n                    (states[r][c] && livingNeighbours >= 4) ||\n                    (!states[r][c] && livingNeighbours >= 5 || livingNeighbours === 0)\n                ) {\n                    newStates[r][c] = true;\n                } else {\n                    newStates[r][c] = false;\n                }\n            }\n        }\n        return newStates;\n    }\n}\n\n/**\n * Static class containing logic for rendering a Map.\n */\nclass MapRenderer {\n    /**\n     * Takes a set of cell states and draws them to an image.\n     * \n     * @param {boolean[][]} states - 2D array of cell states.\n     * @param {Image} image - The image to draw to.\n     * @param {boolean} [scale = true] - If the states should scale to fit the image.\n     */\n    public static drawToImage(states: boolean[][], image: Image, scale: boolean = true): void {\n        const gridRows = states.length;\n        const gridCols = states[0].length;\n        const scaleX = image.width / gridCols;\n        const scaleY = image.height / gridRows;\n\n        for (let r = 0; r < gridRows; r++) {\n            for (let c = 0; c < gridCols; c++) {\n                const col = states[r][c] ? 0 : 1;\n                \n                if (scale) {\n                    for (let dy = 0; dy < scaleY; dy++) {\n                        for (let dx = 0; dx < scaleX; dx++) {\n                            const imageX = c * scaleX + dx;\n                            const imageY = r * scaleY + dy;\n                            image.setPixel(imageX, imageY, col);\n                        }\n                    }\n                } else {\n                    image.setPixel(r, c, col);\n                }\n            }\n        }\n    }\n}\n\nlet bg = sprites.create(image.create(160, 120));\n\nconst renderCellularAutomataSteps = (count: number) => {\n    const map: Map = new Map(160, 120);\n    map.randomise()\n    MapRenderer.drawToImage(map.states, bg.image);\n    const drawStep = () => {\n        pause(500)\n        map.states = MapProcGen.cellularAutomataStep(map.states);\n        MapRenderer.drawToImage(map.states, bg.image);\n    }\n    for (let i = 0; i < count; i++) {\n        drawStep();\n    }\n}\n\nrenderCellularAutomataSteps(10);\nsetInterval(() => {\n    renderCellularAutomataSteps(10);\n}, 5000)","README.md":" ","assets.json":"","main.py":"\n","pxt.json":"{\n    \"name\": \"Conway's Game of Life\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1738668495302,"editorVersion":"2.0.3","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"/**\n * Represents a 2D map of cells with binary living or dead states. i.e. a wall or a floor.\n */\nclass Map {\n    readonly gridRows: number;\n    readonly gridCols: number;\n    private states: boolean[][] = [];\n\n    constructor(cols: number, rows: number) {\n        this.gridRows = rows;\n        this.gridCols = cols;\n        for (let r = 0; r < this.gridRows; r++) {\n            const row: boolean[] = [];\n            for (let c = 0; c < this.gridCols; c++) {\n                row.push(false);\n            }\n            this.states.push(row);\n        }\n    }\n\n    public getStates(): boolean[][] { return this.states; }\n\n    public update(transform: (currentStates: boolean[][]) => boolean[][]): void {\n        let newStates = transform(this.states);\n        if (\n            newStates.length == this.gridRows &&\n            newStates[0].length === this.gridCols\n        ) {\n            this.states = newStates;\n        } else {\n            // throw \n        }\n    }\n\n    // TODO: This should probably be in MapProcGen.\n    public randomise(livingChance: number = 0.5): void {\n        for (let r = 0; r < this.gridRows; r++) {\n            for (let c = 0; c < this.gridCols; c++) {\n                this.states[r][c] = Math.random() < livingChance;\n            }\n        }\n    }\n\n    // TODO: Anything more complicated than toString should arguably go to the MapRenderer.\n    public toString(): string {\n        let result = '';\n        result += \"rows: \" + this.gridRows\n        result += \"\\ncolumns: \" + this.gridCols\n        result += \"\\nstates:\";\n        for (let r = 0; r < this.gridRows; r++) {\n            let rowString = \"\\n\";\n            for (let c = 0; c < this.gridCols; c++) {\n                rowString += \"\" + +this.states[r][c] + \"\";\n            }\n            result += rowString;\n        }\n        return result;\n    }\n}\n\n/**\n * Static class containing ProcGen logic to be applied to a Map.\n */\nclass MapProcGen {\n    /**\n     * Counts the living cell neighbours of a given cell in a 2D array of cell states.\n     * \n     * @param {boolean[][]} states - 2D array of cell states.\n     * @param {number} row - The row of the cell to be checked.\n     * @param {number} col - The column of the cell to be checked.\n     * @returns {number} - The number of living (true) neighbours of the cell.\n     */\n    private static countCellNeighbours(states: boolean[][], row: number, col: number): number {\n        let count = 0;\n        for (let i = -1; i < 2; i++) {\n            for (let j = -1; j < 2; j++) {\n                // Don't count own cell.\n                if (i == 0 && j == 0) {\n                    continue;\n                }\n                let neighbourRow = row + i;\n                let neighbourCol = col + j;\n                // Don't count out-of-bounds cells.\n                if (\n                    neighbourRow < 0 ||\n                    neighbourCol < 0 ||\n                    neighbourRow >= states.length ||\n                    neighbourCol >= states[0].length\n                ) {\n                    continue;\n                }\n                // If cell is alive, increment neighbour count.\n                if (states[neighbourRow][neighbourCol]) count++;\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Takes a single CA step on a map state and returns the evolved state.\n     * \n     * @param {boolean[][]} states - 2D array of cell states.\n     * @returns {boolean[][]} - 2D array of evolved cell states.\n     */\n    public static cellularAutomataStep(states: boolean[][]): boolean[][] {\n        const gridRows = states.length;\n        const gridCols = states[0].length;\n        let newStates: boolean[][] = [];\n\n        for (let r = 0; r < gridRows; r++) {\n            newStates[r] = [];\n            for (let c = 0; c < gridCols; c++) {\n                const livingNeighbours = MapProcGen.countCellNeighbours(states, r, c);\n                if (\n                    (states[r][c] && livingNeighbours >= 4) ||\n                    (!states[r][c] && livingNeighbours >= 5 || livingNeighbours === 0)\n                ) {\n                    newStates[r][c] = true;\n                } else {\n                    newStates[r][c] = false;\n                }\n            }\n        }\n        return newStates;\n    }\n}\n\n/**\n * Static class containing logic for rendering a Map.\n */\nclass MapRenderer {\n    /**\n     * Takes a set of cell states and draws them to an image.\n     * \n     * @param {boolean[][]} states - 2D array of cell states.\n     * @param {Image} image - The image to draw to.\n     * @param {boolean} [scale = true] - If the states should scale to fit the image.\n     */\n    public static drawToImage(states: boolean[][], image: Image, scale: boolean = true): void {\n        const gridRows = states.length;\n        const gridCols = states[0].length;\n        const scaleX = image.width / gridCols;\n        const scaleY = image.height / gridRows;\n\n        for (let r = 0; r < gridRows; r++) {\n            for (let c = 0; c < gridCols; c++) {\n                const col = states[r][c] ? 0 : 1;\n                \n                if (scale) {\n                    for (let dy = 0; dy < scaleY; dy++) {\n                        for (let dx = 0; dx < scaleX; dx++) {\n                            const imageX = c * scaleX + dx;\n                            const imageY = r * scaleY + dy;\n                            image.setPixel(imageX, imageY, col);\n                        }\n                    }\n                } else {\n                    image.setPixel(r, c, col);\n                }\n            }\n        }\n    }\n}\n\nlet bg = sprites.create(image.create(160, 120));\n\nconst renderCellularAutomataSteps = (count: number) => {\n    const map: Map = new Map(160, 120);\n    map.randomise()\n    MapRenderer.drawToImage(map.getStates(), bg.image);\n    const drawStep = () => {\n        pause(500)\n        map.update(states => MapProcGen.cellularAutomataStep(states));\n        MapRenderer.drawToImage(map.getStates(), bg.image);\n    }\n    for (let i = 0; i < count; i++) {\n        drawStep();\n    }\n}\n\nrenderCellularAutomataSteps(10);\nsetInterval(() => {\n    renderCellularAutomataSteps(10);\n}, 5000)","README.md":" ","assets.json":"","main.py":"\n","pxt.json":"{\n    \"name\": \"Conway's Game of Life\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1738670750050,"editorVersion":"2.0.3","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"/**\n * Represents a 2D map of cells with binary living or dead states. i.e. a wall or a floor.\n */\nclass Map {\n    private readonly gridRows: number;\n    private readonly gridCols: number;\n    private states: boolean[][] = [];\n\n    constructor(cols: number, rows: number) {\n        this.gridRows = rows;\n        this.gridCols = cols;\n        for (let r = 0; r < this.gridRows; r++) {\n            const row: boolean[] = [];\n            for (let c = 0; c < this.gridCols; c++) {\n                row.push(false);\n            }\n            this.states.push(row);\n        }\n    }\n\n    public getStates(): boolean[][] { return this.states; }\n\n    public update(transform: (currentStates: boolean[][]) => boolean[][]): void {\n        let newStates = transform(this.states);\n        if (\n            newStates.length == this.gridRows &&\n            newStates[0].length === this.gridCols\n        ) {\n            this.states = newStates;\n        } else {\n            throw \"Transformed Map states don't fit the map grid.\";\n        }\n    }\n\n    // TODO: This should probably be in MapProcGen.\n    public randomise(livingChance: number = 0.5): void {\n        for (let r = 0; r < this.gridRows; r++) {\n            for (let c = 0; c < this.gridCols; c++) {\n                this.states[r][c] = Math.random() < livingChance;\n            }\n        }\n    }\n\n    public toString(): string {\n        let result = `[${this.gridRows}, ${this.gridCols}]\\nstates:`\n        for (let r = 0; r < this.gridRows; r++) {\n            let rowString = this.states[r].map(cell => `${+cell}`).join('');\n            result += `\\n${rowString}`;\n        }\n        return result;\n    }\n}\n\n/**\n * Static class containing ProcGen logic to be applied to a Map.\n */\nclass MapProcGen {\n    /**\n     * Counts the living cell neighbours of a given cell in a 2D array of cell states.\n     * \n     * @param {boolean[][]} states - 2D array of cell states.\n     * @param {number} row - The row of the cell to be checked.\n     * @param {number} col - The column of the cell to be checked.\n     * @returns {number} - The number of living (true) neighbours of the cell.\n     */\n    private static countCellNeighbours(states: boolean[][], row: number, col: number): number {\n        let count = 0;\n        for (let i = -1; i < 2; i++) {\n            for (let j = -1; j < 2; j++) {\n                // Don't count own cell.\n                if (i == 0 && j == 0) {\n                    continue;\n                }\n                let neighbourRow = row + i;\n                let neighbourCol = col + j;\n                // Don't count out-of-bounds cells.\n                if (\n                    neighbourRow < 0 ||\n                    neighbourCol < 0 ||\n                    neighbourRow >= states.length ||\n                    neighbourCol >= states[0].length\n                ) {\n                    continue;\n                }\n                // If cell is alive, increment neighbour count.\n                if (states[neighbourRow][neighbourCol]) count++;\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Takes a single CA step on a map state and returns the evolved state.\n     * \n     * @param {boolean[][]} states - 2D array of cell states.\n     * @returns {boolean[][]} - 2D array of evolved cell states.\n     */\n    public static cellularAutomataStep(states: boolean[][]): boolean[][] {\n        const gridRows = states.length;\n        const gridCols = states[0].length;\n        const newStates: boolean[][] = [];\n\n        for (let r = 0; r < gridRows; r++) {\n            newStates[r] = [];\n            for (let c = 0; c < gridCols; c++) {\n                const livingNeighbours = MapProcGen.countCellNeighbours(states, r, c);\n                if (\n                    (states[r][c] && livingNeighbours >= 4) ||\n                    (!states[r][c] && livingNeighbours >= 5 || livingNeighbours === 0)\n                ) {\n                    newStates[r][c] = true;\n                } else {\n                    newStates[r][c] = false;\n                }\n            }\n        }\n        return newStates;\n    }\n}\n\n/**\n * Static class containing logic for rendering a Map.\n */\nclass MapRenderer {\n    /**\n     * Takes a set of cell states and draws them to an image.\n     * \n     * @param {boolean[][]} states - 2D array of cell states.\n     * @param {Image} image - The image to draw to.\n     * @param {boolean} [scale = true] - If the states should scale to fit the image.\n     */\n    public static drawToImage(states: boolean[][], image: Image, scale: boolean = true): void {\n        const gridRows = states.length;\n        const gridCols = states[0].length;\n        const scaleX = image.width / gridCols;\n        const scaleY = image.height / gridRows;\n\n        for (let r = 0; r < gridRows; r++) {\n            for (let c = 0; c < gridCols; c++) {\n                const col = states[r][c] ? 0 : 1;\n                \n                if (scale) {\n                    for (let dy = 0; dy < scaleY; dy++) {\n                        for (let dx = 0; dx < scaleX; dx++) {\n                            const imageX = c * scaleX + dx;\n                            const imageY = r * scaleY + dy;\n                            image.setPixel(imageX, imageY, col);\n                        }\n                    }\n                } else {\n                    image.setPixel(r, c, col);\n                }\n            }\n        }\n    }\n}\n\nlet bg = sprites.create(image.create(160, 120));\n\nconst renderCellularAutomataSteps = (count: number) => {\n    const map: Map = new Map(160, 120);\n    map.randomise()\n    MapRenderer.drawToImage(map.getStates(), bg.image);\n    const drawStep = () => {\n        pause(500)\n        map.update(states => MapProcGen.cellularAutomataStep(states));\n        MapRenderer.drawToImage(map.getStates(), bg.image);\n    }\n    for (let i = 0; i < count; i++) {\n        drawStep();\n    }\n}\n\nrenderCellularAutomataSteps(10);\nsetInterval(() => {\n    renderCellularAutomataSteps(10);\n}, 5000)","README.md":" ","assets.json":"","main.py":"\n","pxt.json":"{\n    \"name\": \"Conway's Game of Life\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[]}